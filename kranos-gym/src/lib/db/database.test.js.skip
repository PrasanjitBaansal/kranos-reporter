import { describe, it, expect, beforeEach, afterEach, vi } from 'vitest';
import { Database } from './database.js';

// Mock sqlite3
const mockDb = {
	all: vi.fn(),
	get: vi.fn(),
	run: vi.fn(),
	close: vi.fn(),
	prepare: vi.fn()
};

vi.mock('sqlite3', () => ({
	default: {
		Database: vi.fn().mockImplementation((path, callback) => {
			setTimeout(() => callback(null), 0);
			return mockDb;
		}),
		verbose: vi.fn().mockReturnThis()
	}
}));

vi.mock('path', async (importOriginal) => {
	const actual = await importOriginal();
	return {
		...actual,
		default: {
			join: vi.fn().mockReturnValue('/test/kranos.db')
		},
		dirname: vi.fn().mockReturnValue('/test/dir'),
		join: vi.fn().mockReturnValue('/test/kranos.db')
	};
});

vi.mock('url', async (importOriginal) => {
	const actual = await importOriginal();
	return {
		...actual,
		fileURLToPath: vi.fn().mockReturnValue('/test/file.js')
	};
});

describe('Database', () => {
	let database;

	beforeEach(async () => {
		vi.clearAllMocks();
		database = new Database();
		await database.connect();
	});

	afterEach(async () => {
		await database.close();
	});

	describe('Connection Management', () => {
		it('should connect to database successfully', async () => {
			const db = new Database();
			await expect(db.connect()).resolves.toBeDefined();
		});

		it('should close database connection', async () => {
			mockDb.close.mockImplementation((callback) => callback(null));
			await expect(database.close()).resolves.toBeUndefined();
		});

		it('should handle connection errors', async () => {
			const errorDb = new Database();
			const sqlite3 = await import('sqlite3');
			sqlite3.default.Database.mockImplementationOnce((path, callback) => {
				setTimeout(() => callback(new Error('Connection failed')), 0);
				return mockDb;
			});
			
			await expect(errorDb.connect()).rejects.toThrow('Connection failed');
		});
	});

	describe('Members Operations', () => {
		const mockMembers = [
			{ id: 1, name: 'John Doe', phone: '555-0001', email: 'john@test.com', is_active: 1 },
			{ id: 2, name: 'Jane Smith', phone: '555-0002', email: 'jane@test.com', is_active: 1 }
		];

		it('should get all members', async () => {
			mockDb.all.mockImplementation((query, params, callback) => {
				callback(null, mockMembers);
			});

			const result = await database.getMembers();
			expect(result).toEqual(mockMembers);
			expect(mockDb.all).toHaveBeenCalledWith(
				'SELECT * FROM members ORDER BY name',
				[],
				expect.any(Function)
			);
		});

		it('should get active members only', async () => {
			const activeMembers = mockMembers.filter(m => m.is_active);
			mockDb.all.mockImplementation((query, params, callback) => {
				callback(null, activeMembers);
			});

			const result = await database.getMembers(true);
			expect(result).toEqual(activeMembers);
			expect(mockDb.all).toHaveBeenCalledWith(
				'SELECT * FROM members WHERE is_active = 1 ORDER BY name',
				[],
				expect.any(Function)
			);
		});

		it('should get member by id', async () => {
			mockDb.get.mockImplementation((query, params, callback) => {
				callback(null, mockMembers[0]);
			});

			const result = await database.getMemberById(1);
			expect(result).toEqual(mockMembers[0]);
			expect(mockDb.get).toHaveBeenCalledWith(
				'SELECT * FROM members WHERE id = ?',
				[1],
				expect.any(Function)
			);
		});

		it('should create new member', async () => {
			const newMember = {
				name: 'Test User',
				phone: '555-0099',
				email: 'test@test.com',
				join_date: '2024-06-22',
				is_active: true
			};

			mockDb.run.mockImplementation(function(query, params, callback) {
				this.lastID = 3;
				callback.call(this, null);
			});

			const result = await database.createMember(newMember);
			expect(result).toBe(3);
			expect(mockDb.run).toHaveBeenCalledWith(
				expect.stringContaining('INSERT INTO members'),
				[newMember.name, newMember.phone, newMember.email, newMember.join_date, newMember.is_active],
				expect.any(Function)
			);
		});

		it('should update existing member', async () => {
			const updatedMember = {
				name: 'John Updated',
				phone: '555-0001',
				email: 'john.updated@test.com',
				join_date: '2024-01-01',
				is_active: true
			};

			mockDb.run.mockImplementation(function(query, params, callback) {
				this.changes = 1;
				callback.call(this, null);
			});

			const result = await database.updateMember(1, updatedMember);
			expect(result).toBe(1);
		});

		it('should delete member', async () => {
			mockDb.run.mockImplementation(function(query, params, callback) {
				this.changes = 1;
				callback.call(this, null);
			});

			const result = await database.deleteMember(1);
			expect(result).toBe(1);
			expect(mockDb.run).toHaveBeenCalledWith(
				'DELETE FROM members WHERE id = ?',
				[1],
				expect.any(Function)
			);
		});

		it('should handle database errors', async () => {
			mockDb.all.mockImplementation((query, params, callback) => {
				callback(new Error('Database error'));
			});

			await expect(database.getMembers()).rejects.toThrow('Database error');
		});
	});

	describe('Plans Operations', () => {
		const mockPlans = [
			{ id: 1, name: 'MMA Focus', duration_days: 90, default_amount: 120.00, is_active: 1 },
			{ id: 2, name: 'Weight Training', duration_days: 30, default_amount: 80.00, is_active: 1 }
		];

		it('should get all plans', async () => {
			mockDb.all.mockImplementation((query, params, callback) => {
				callback(null, mockPlans);
			});

			const result = await database.getPlans();
			expect(result).toEqual(mockPlans);
		});

		it('should create new plan', async () => {
			const newPlan = {
				name: 'Cardio Blast',
				duration_days: 60,
				default_amount: 100.00,
				is_active: true
			};

			mockDb.run.mockImplementation(function(query, params, callback) {
				this.lastID = 3;
				callback.call(this, null);
			});

			const result = await database.createPlan(newPlan);
			expect(result).toBe(3);
		});
	});

	describe('Memberships Operations', () => {
		const mockGroupMemberships = [
			{
				id: 1,
				member_id: 1,
				plan_id: 1,
				start_date: '2024-06-01',
				end_date: '2024-08-30',
				amount_paid: 120.00,
				is_active: 1
			}
		];

		it('should get group class memberships', async () => {
			mockDb.all.mockImplementation((query, params, callback) => {
				callback(null, mockGroupMemberships);
			});

			const result = await database.getGroupClassMemberships();
			expect(result).toEqual(mockGroupMemberships);
		});

		it('should create group class membership', async () => {
			const newMembership = {
				member_id: 1,
				plan_id: 1,
				start_date: '2024-06-22',
				amount_paid: 120.00,
				membership_type: 'New'
			};

			mockDb.run.mockImplementation(function(query, params, callback) {
				this.lastID = 2;
				callback.call(this, null);
			});

			const result = await database.createGroupClassMembership(newMembership);
			expect(result).toBe(2);
		});
	});

	describe('Reporting Operations', () => {
		it('should generate financial report', async () => {
			const mockFinancialData = {
				total_revenue: 1000.00,
				gc_revenue: 800.00,
				pt_revenue: 200.00,
				total_transactions: 10
			};

			mockDb.all.mockImplementation((query, params, callback) => {
				if (query.includes('SUM')) {
					callback(null, [mockFinancialData]);
				} else {
					callback(null, []);
				}
			});

			const result = await database.getFinancialReport('2024-06-01', '2024-06-30');
			expect(result).toHaveProperty('total_revenue');
		});

		it('should get upcoming renewals', async () => {
			const mockRenewals = [
				{
					id: 1,
					member_name: 'John Doe',
					plan_name: 'MMA Focus',
					end_date: '2024-07-01'
				}
			];

			mockDb.all.mockImplementation((query, params, callback) => {
				callback(null, mockRenewals);
			});

			const result = await database.getUpcomingRenewals();
			expect(result).toEqual(mockRenewals);
		});
	});

	describe('Authentication Operations', () => {
		it('should verify user credentials', async () => {
			const mockUser = { id: 1, username: 'admin', password_hash: 'hashedpassword' };
			
			mockDb.get.mockImplementation((query, params, callback) => {
				callback(null, mockUser);
			});

			const result = await database.verifyUser('admin');
			expect(result).toEqual(mockUser);
		});

		it('should handle user not found', async () => {
			mockDb.get.mockImplementation((query, params, callback) => {
				callback(null, null);
			});

			const result = await database.verifyUser('nonexistent');
			expect(result).toBeNull();
		});
	});

	describe('Data Validation', () => {
		it('should validate member data before insert', async () => {
			const invalidMember = {
				name: '', // Empty name should fail
				phone: '555-0001',
				email: 'test@test.com'
			};

			// Mock validation logic
			expect(invalidMember.name).toBe('');
		});

		it('should validate phone number uniqueness', async () => {
			mockDb.get.mockImplementation((query, params, callback) => {
				callback(null, { id: 1, phone: '555-0001' });
			});

			// This would be part of the validation logic
			const existingMember = await new Promise((resolve, reject) => {
				mockDb.get('SELECT * FROM members WHERE phone = ?', ['555-0001'], (err, row) => {
					if (err) reject(err);
					else resolve(row);
				});
			});

			expect(existingMember).toBeTruthy();
		});
	});

	describe('Transaction Management', () => {
		it('should handle database transactions', async () => {
			const mockTransaction = {
				begin: vi.fn(),
				commit: vi.fn(),
				rollback: vi.fn()
			};

			// Mock transaction behavior
			mockDb.serialize = vi.fn((callback) => callback());
			
			expect(mockDb.serialize).toBeDefined();
		});
	});
});